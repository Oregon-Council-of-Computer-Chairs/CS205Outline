\documentclass[12pt,letterpaper]{article}
\input{common_includes.tex}  %% put includes here. They tend to get reused a lot

\usepackage{lmodern}
\renewcommand*\familydefault{\sfdefault} % use lmodern for paragraphs

\chead{ \fancyplain{}{ CS 205 Course Description } }
\cfoot{ \fancyplain{}{\thepage} }
\setlength{\parskip}{1em}
\setlength{\itemsep}{4em}
\usepackage{indentfirst}

\renewcommand\thesection{} %no section numbers
\renewcommand\thesubsection{\arabic{subsection}} %subsection numbering does not include section

\begin{document}

	\section*{Overview}

	CS205, System Programming and Architecture, was designed for students pursuing the \textcolor{red}{TODO - official name} research variant of the CS Major Transfer Map (MTM). Oregon State University and Portland State University both require a lower division course focusing on the interface between high-level code and hardware - including the credits for these courses was a critical part of making the MTM workable. This course, while not exactly equivalent to their courses, articulates to those courses and is accepted for CS elective credit at the University of Oregon \textcolor{red}{TODO - double check}.
	 
	The core theme of this course is "What really happens when software runs?" Students should learn how fundamental parts of C programs map to assembly code and binary representations, how this assembly is determined by the Instruction Set Architecture of a machine, the high-level structures of a processor, and the basic facilities provided by an operating system. The particular architecture and assembly studied is not proscribed - students exposed to any modern architechture should be adequately prepared for later courses.

	For colleges that do not teach C as part of their CS161/162/260 sequence, this course also serves the essential role of introducing C programming so students are prepared for Junior year courses that assume a working knowledge of C. Thus, it is assumed that time will be devoted to learning the basics of C programming in addition to learning how C gets mapped to assembly code. After this course, students should be able to write moderately complex, well structured programs using C libraries and Linux system calls. Students should also have experience using a debugger on their code.
	
	Capture The Flag (CTF) activities that require reading assembly in context and basic dynamic analysis of code using a debugger are a key component of the course. To establish the level of mastery in these skills students are expected to develop, sample CTF assignments are described in this document. These activities, or equivalent ones, must be a part of any implementation of CS205 in order to be acceptable for transfer. To aid instructors in meeting this requirement, PSU is providing access to the CTF system they have developed (see CTF section for details).
	
	The 10th week of this course is designated as time to apply and expand the ideas of the course in a particular context. Three possible approaches - ones that focus on cybersecurity, operating systems, and designing for performance - are briefly outlined in this document to provide suggested uses for this week.
	\clearpage

	
	\section{Course Outcomes}

	Any implementation of CS205 should include the following based outcomes.

	\begin{enumerate}
		\item Describe the major components of computer architecture, and explain their purposes and interactions.
		\item Describe a basic instruction set architecture, including the arithmetic, logic, and control instructions; user and control registers; and addressing modes.
		\item Describe the instruction execution cycle. \textcolor{red}{TODO - Condense into first item?}
		\item Do simple arithmetic in hexadecimal, decimal, and binary notation, and convert among these notations.
		\item Explain how data types such as integers, characters, pointers, and floating point numbers are represented and used at the assembly level.
		\item Write C language programs to illustrate basic systems programming concepts: file I/O, system calls, memory management, exception handling, and signals. \textcolor{red}{TODO - Update to match new version of course? Exception handling and signals are now one option for week 10}
		\item Describe each step of the compilation process by which C language programs are transformed into machine code.  
		\item Explain how high-level programming constructs such as arrays, structures, loops, and stack-based function calls are implemented in  machine code. Recognize and reverse engineer same.
		\item Demonstrate and use a debugger to analyze program flow, inspect register and stack contents. 
		\item Identify and fix performance issues in C programs. \textcolor{red}{TODO - Update to match new version of course?}
		\item \textcolor{red}{TODO - Something about CTF specific skills?}
		\item Explain how the information in this course is important within the overall context of computer science.
	\end{enumerate}

	\clearpage
	

	\section{Topic List}

	% \begin{longtable}{| p{0.5in} | p{6in} |} \hline
	% 	\rowcolor{lightgray}{\bf Wk} & {\bf Topic} \\ \hline \endhead
		
	% 	1 & Introduction to Systems \newline Intro to C for Systems  \\ \hline
	% 	2 & \href{https://web.cecs.pdx.edu/~markem/CS201/homework/MetaCTF/MetaCTF_description.html}{MetaCTF} overview and demo \newline The Compilation Process \newline Debugging Concepts   \\ \hline
	% 	3 & Data Representation \newline Arithmetic  \newline Base Types in C \\ \hline
	% 	4 & Floating Point \newline  C Functions \\ \hline
	% 	5 & Program Encodings / Data Formats \newline Arithmetic and Logical Operations \newline Stack-based buffer overflow attacks  \\ \hline
	% 	6 & Control \newline Procedures \\ \hline
	% 	7 & Pointers and Arrays  \\ \hline
	% 	8 & Structs, Unions, Alignment \newline Performance  \\ \hline
	% 	9 & Optimizations in C \newline  Dynamic Memory Allocation  \\ \hline
	% 	10 & Interrupts, Traps, and Exceptions \newline POSIX System Calls, Signals   \\ \hline
	% \end{longtable}
	

	The listed ordering of topics should in no way be considered prescriptive. While the topics progress listed below generally progress from fundamental to more advanced, any particular implementation of CS205 will likely find it advantageous to rearrange or crosscut topics. In particular, because this course covers both C programming and how C code runs on hardware, there are two possible approaches to teaching it: 1) focus on C programming before diving into assembly and how the code runs; 2) iterate through areas of C programming and how they are implemented. The topic list is structured in the later manner: it describes the expected boundaries for C and lower levels of each topic simultaneously. That should not be understood as precluding teaching the course in a C first, assembly later fashion.

	\subsection{Introduction to Systems}

	The fundamentals of computer systems and architecture that are critical for understanding assembly and high level performance concerns that are affected by architecture.

	\begin{enumerate}
		\item Fundamental components of a computer system and the fetch, decode, execute cycle.
		\item Memory hierarchy and role of caches. Detailed study of caches not required. Focus should be relative performance of different levels of the memory system and basic principles of cache management: block transfer and temporal and spatial locality. 
		\item Role of Operating System as hardware manager.
	\end{enumerate}


	\subsection{C Development Fundamentals}

	Writing and debugging a C program that does basic IO. Other topics in C programming are broken out with their assembly counterparts but could be taught with the fundamentals to make a larger initial module on C programming.

	\begin{enumerate}
		\item Role of C as portable assembly and high level language.
		\item Structure of a basic C program and use of basic IO and file instructions (fopen, printf, fgets, etc...).
		\item Compiling and running C code from the command line.
		\item Use of a debugger to examine running code at both the C and ASM level. Students should be familiar with setting breakpoints and examining the contents of registers and memory associated with symbols.
	\end{enumerate}


	\subsection{Compiling, Linking, and Loading}

	How C code is turned into object files and executables and the structure of those files. Across all of these areas, the focus is building the level of understanding important for a developer who will use C in future courses and who will be examining compiled code to understand it. Precise implementation details of any particular object format, linking process, etc... should not be an emphasis.

	\begin{enumerate}
		\item Compilation process - roles of: preprocessor, C compiler, assembler, linker. Individual components can be treated as black boxes, but students should recognize the kinds of errors messages that can result at each phase (linking vs compilation errors). 
		\item Basic structure of object files. Focus should be on understanding different segments and their roles.
		\item Symbols, symbol tables, and symbol resolution.  Emphasis should be on identifying and how symbols will be matched across object files/compilation units. 
		\item Relocation and position independent code. Again, focus should not be the details of any particular implementation, but on the kinds of transformations that happen as code is linked and loaded.
		\item Static vs dynamic linking. 
		\item Use of basic static inspection tools (e.g. objdump)
	\end{enumerate}
	

	\subsection{Data Representation}

	How data is represented at a low level and how that shapes C programming. Understanding that these are determined by the architecture of the machine is critical - knowing the details of any particular architecture is not.

	\begin{enumerate}
		\item Binary, Decimal, and Hexadecimal representations. Converting from one form to another.
		\item Data sizes. Bytes and words as the fundamental unit sizes. 
		\item ASCII char representation.
		\item C integer data types and their sizes. Emphasis on platform dependence of these. 
		\item Enumerations.
		\item Machine instruction representation. How features like opcode, registers, and memory addresses are stored in an instruction.
		\item Endianess.
		\item Casting in C.
	\end{enumerate}

	\subsection{Signed Arithmetic and Floating Point}

	How we do integer math in C and ASM and floating point math in C. (Coverage of floating point instruction in ASM is not required.) How negative and fractional values are represented at a binary level. 

	\begin{enumerate}
		\item Signed integer representation in 2s complement. Negation of signed values at the bit level. Recognition of important patterns (0xF...F is -1; a leading 1 is a negative number).
		\item Signed vs unsigned arithmetic. Overflow and its detection. When to use which format.
		\item Floating point representation. Memorization of a particular format is not required, but students should be exposed to an IEEE or IEEE-like format and understand the basic features of floating point representation: how representational resolution depends on magnitude, the existence of minimal/maximal representable values, and nan/infinity.
		\item The floating point types and their use in C. 
	\end{enumerate}
	

	\subsection{Bitwise Operations}

	How to manipulate bits in ASM and C.

	\begin{enumerate}
		\item Bitwise logical operations and their use to manipulate individual bits.
		\item Shift/rotate operations.
		\item Use of shifts to multiply/divide binary values. The difference between arithmetic and logic shifts.
	\end{enumerate}
	

	\subsection{Control Structures}

	C level control structures and their implementation at the ASM level.

	\begin{enumerate}
		\item Conditional structures (including switch) and loops in C.
		\item ASM comparison instructions and condition codes.
		\item ASM jump/branch instructions including conditional branches.
		\item Jump/branch tables.
		\item Implementation of C control structures in ASM.
	\end{enumerate}


	\subsection{Memory and Pointers}

	How memory is accessed. Of critical importance is understanding the role of registers in the implementation of complex C expressions (or in all expressions for load/store architectures).

	\begin{enumerate}
		\item Pointers, addresses and dereferencing in C.
		\item ASM movement instructions using immediate values, registers, and memory.
		\item ASM addressing modes.
		\item The use of the stack to store data via ASM push/pop operations. How that stack is layed out in memory and how the stack pointer is used to maintain it.
	\end{enumerate}

	\subsection{Dynamic Memory}

	Allocation/deallocation of memory and the heap.

	\begin{enumerate}
		\item Use of free/malloc in C.
		\item Heap vs stack. Strengths/weaknesses of allocations in each region.
		\item The "standard" process memory model (and how reality often is more complicated).
		\item \textcolor{red}{TODO - Does this need to extend to ASM. Or is this mostly about C?}
	\end{enumerate}



	\subsection{Functions}

	Functions in C and their implementation in assembly.

	\begin{enumerate}
		\item Functions in C.
		\item Pass by value vs reference.
		\item ASM level calling convention - how values are passed and returned.
		\item ASM implementation of local memory. Frame pointer and stack allocation/deallocation.
		\item Recursive functions - how the stack mechanism allows for reentrant code. 
	\end{enumerate}


	\subsection{Arrays and C-strings}

	Use of arrays and C-strings and working with arrays in ASM.

	\begin{enumerate}
		\item Array allocation (fixed and variable length) and use in C. 
		\item Multidimensional arrays in C.
		\item Pointer arithmetic and its relation to array indexing.
		\item Accessing individual array elements and looping through arrays in ASM.
		\item C-string related conventions and functions: NULL termination and basic string library functions.
		\item Stack based buffer overflow attacks.
	\end{enumerate}

	\subsection{Heterogenous Structures}

	Fundamental tools for grouping (possibly) heterogenous data.

	\begin{enumerate}
		\item Structs.
		\item Unions.
		\item Data alignment and byte packing/padding in structures. 
	\end{enumerate}


	\subsection{Optimizations in C}

	Basic optimizations that compilers do related to concepts from this course. Exploring the effect of level optimizations in C code. (strength reductions, reducing procedure calls \& memory references, etc...). Coverage of this topic is not expected to be exhaustive - the goals are awareness of why compiled code often looks very different than what one would expect and how the kinds of low level efficiencies.

	\begin{enumerate}
		\item The kinds of optimizations that compilers routinely make (function inlining, dead store elimination) when compiling code.
		\item The effect of array stride order on performance.
		\item Relative performance of floating point and integer math - why we generally favor ints unless we need floating points.
		\item Basic performance optimizations available to high level language programmers: avoiding loop inefficiencies, reducing procedure calls and memory references, strength reductions.
	\end{enumerate}


	\subsection{CTF}

	\textcolor{red}{TODO - Provide list of specific kinds of skills students should have? If CTF's are "required", we need to clearly define expected level of work.}

	\begin{enumerate}
		\item ???
		\item ???
		\item ???
	\end{enumerate}



	\clearpage
	\section{Sample Schedule}

	One possible ordering of topics over a ten week term:

	\textcolor{red}{TODO - Mix in CTF details - will fill out later weeks of course.}

	\begin{longtable}{| p{0.5in} | p{6in} |} \hline
		\rowcolor{lightgray}{\bf Wk} & {\bf Topic} \\ \hline \endhead
		
		1 & Introduction to Systems \newline C Fundamentals  \\ \hline
		2 & The Compilation Process \newline Object files \newline Data Representation  \\ \hline
		3 & Data Representation Continued  \newline  Arithmetic Operations  \newline Floating Point \\ \hline
		4 & Bitwise Operations \newline  Control Structures  \\ \hline
		5 & Memory and Pointers  \newline  Dynamic Memory Management \\ \hline
		6 & C Functions \newline  Implementation of Functions  \\ \hline
		7 & Arrays and C-Strings \\ \hline
		9 & Structs, Unions, Alignment  \newline Optimizations in C  \\ \hline
		10 & CS205 Topics in Context  \\ \hline
	\end{longtable}

	\clearpage
	\section{Week 10 Options}

	The tenth week of the course is designed to provide time for instructors to review critical material, finish up CTF work, and to expose students to applications of concepts from the course in the context of more advanced topics. While instructors are free to devise their own approach to doing so, three application areas are provided below as suggestions. For each, some resources are provided as a starting point.


	\subsection{Cybersecurity}

	Cybersecurity related knowledge and skills are undergoing a rapid increase in interest among students and employers. Many code level security topics depend directly on the knowledge and skills in this course. A deeper dive into cybersecurity related topics provides an opportunity to emphasize the practical CTF challenges and tease more advanced ideas like return oriented programming.
	
	\textcolor{red}{TODO - Kevin to provide a short outline.}

	\subsection{Operating Systems Programming}

	On many computational devices operating system is the mediator between the machine code and the actual machine. A deeper look at the relation between code and the operating system is a way to review topics related to procedure calls and the address space and tease important topics for later work in Operating Systems courses.
	
	\textcolor{red}{TODO - Get Mark to help clean this up.}

	\subsubsection{Interrupts, Traps, and Exceptions}
	This chapter is currently required at PSU (BandO Chapter 8). This course is the direct prerequisite to CS 333, Introduction to Operating Systems, which assumes knowledge of interrupts, traps, and what system calls are about. The emphasis should be on POSIX-compliant system calls.
	
	\subsubsection{Exception Handling}
	\begin{enumerate}
		\item Exception number
		\item Exception table, aka, exception dispatch (jump) table, etc. ISA specific terminology.
		\item Exception handler. No discussion of up and bottom halves, just the basic concept.
	\end{enumerate}
		
	\subsubsection{System Calls -- OS As Privileged Service Provider}

	System calls are synchronous (traps). At the very least, there should be a detailed example of a simple C program making one or more system calls mapped down to assembly. The following exemplar is meant to be walked through line-by-line. This will help reinforce that system calls look just like function or library calls to the programmer. Modes will be introduced in the process discussion, below.
	
	\begin{enumerate}
		\item Processes and logical flow control.
		\item Concurrent Flows - basically about a gut feel for what it means for 2 processes to be concurrent.  This is a natural follow-on to exceptions and allows us to introduce the idea of a context switch.
		\item Process Address Space Layout
		\item User and Kernel Modes
		\item The Context Switch
		\item System Call Error Handling
		\item Process Control - fork/exec/wait
	\end{enumerate}
	
	\subsection{Data Oriented Design and Optimization in Games}

	While data oriented design and other optimizations are useful in any programming where performance is a high priority, for many computer users, video games are the most computationally expensive software packages run on a routine basis. They are a high interest place to explore the kinds of considerations that go into designing performant software. Topics including memory access in arrays and compiler optimizations can be reviewed and expanded on and more advanced topics like branch prediction can be teased.

	\textcolor{red}{TODO - Add info from Mike Bailey.}

	Resources:
	
	\begin{enumerate}

		\item The book Game Programming Patterns - available for free online: \url{https://gameprogrammingpatterns.com/}. Chapter 17 is likely the most relevant. Chapters 18-19 and 11 also of interest. Examples in the book are in basic C++.
	
		\item Seminal 2009 presentation by Tony Albrecht on optimizing for the PS3: 
		\url{http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf}

		A 2017 followup talk by Tony Albrecht:
		\url{https://www.youtube.com/watch?v=VAT9E-M-PoE}


		\item Data Oriented Design in game development talk by Mike Acton: \url{https://www.youtube.com/watch?v=rX0ItVEVjHc}

		\item Data Oriented Design to make a faster HTML renderer: \url{https://www.youtube.com/watch?v=yy8jQgmhbAU}

		\item Matt Godbolt (of godbolt.org fame) on the cool magic that compilers do and why you should not assume you can out clever them with hand optimizations:
		\url{https://www.youtube.com/watch?v=w0sz5WbS5AM}

		\item Struct of Array vs Array of Struct organization: \href{https://medium.com/@savas/nomad-game-engine-part-4-3-aos-vs-soa-storage-5bec879aa38}{https://medium.com/@savas/nomad-game-engine-part-4-3-aos-vs-soa-storage-5bec879aa38}

	\end{enumerate}

\end{document}
